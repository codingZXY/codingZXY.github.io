<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三尾先生的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-04T17:07:30.691Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>三尾先生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>异步协程爬虫实战—365淘房</title>
    <link href="http://yoursite.com/2019/04/05/%E5%BC%82%E6%AD%A5%E5%8D%8F%E7%A8%8B%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%E2%80%94365%E6%B7%98%E6%88%BF/"/>
    <id>http://yoursite.com/2019/04/05/异步协程爬虫实战—365淘房/</id>
    <published>2019-04-04T16:53:00.790Z</published>
    <updated>2019-04-04T17:07:30.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习如何使用Async/Aiohttp实现异步协程爬虫，基于cxa大佬分享的<a href="https://github.com/muzico425/CSDNUSE" target="_blank" rel="noopener">discogs</a>爬虫源码，实现365淘房的通用爬虫，网站本身没有爬取难度，重点是通用性的实现。因此本文不会对分析过程做过多说明，主要分享通用爬虫思路和cxa大佬异步爬虫框架的使用。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>需求是爬取<a href="http://www.house365.com/" target="_blank" rel="noopener">365淘房网</a>上的二手房和租房的个人房源信息。以二手房为例，首先找到入口的url是<a href="http://hf.sell.house365.com/district_i1/dl_p1.html" target="_blank" rel="noopener">http://hf.sell.house365.com/district_i1/dl_p1.html</a>，分析下url的参数含义：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>hf</td><td>城市缩写，代表合肥</td></tr><tr><td>sell</td><td>房屋类别，代表二手房</td></tr><tr><td>district_i1</td><td>房源类别，代表个人房源</td></tr><tr><td>dl_p1</td><td>翻页参数，代表第一页</td></tr></tbody></table><p>试着把hf换成hz（杭州），发现杭州的页面跟合肥的页面不太一样，自然页面源码也不同。再试试把sell换成（rent），发现租房的页面跟二手房的页面也不一样。这意味着我们要根据不同城市、不同的房屋类别写不同的xpath解析，那么如何只写一份代码，就能实现所有城市所有类别的爬取就值得好好考虑了。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>虽然借鉴了大佬的代码，但在爬取思路上还是有较大差异的。discogs的爬取思路是：先把列表页中的详情url全部爬下来，记录状态为0（初始），再另写一个爬虫，取出初始状态的详情url进行爬取，取出时更新状态为1（开始下载），保存后更新状态为2（下载完了）。这样做的好处是：</p><ol><li>爬取列表页需要发起的请求较少，可以快速爬完</li><li>爬取详情过程中出现意外中断，只要将状态为1的数据更新为0，就能继续爬取。</li><li>通过对状态字段的控制，可支持分布式爬取</li></ol><p>由于只看了通用类和方法，具体爬虫代码并没有细看，因此理解可能有误，但大致思路是这样。</p><p>分析了365淘房后，发现这个网站的数据量并不大，每页列表有20条数据，而最热门的城市也只有100来页，甚至有些城市的最大页码是个位数。使用大佬的思路爬的话有点杀鸡用牛刀的感觉，所以我做了下简化：循环城市，将当前城市列表页中的详情url全部爬取，但不入库，而是查询数据库，过滤已存在的数据（避免对详情url的重复请求），然后爬取所有过滤后的详情url。相当于每爬完一个城市的列表页进行一次入库。</p><p>这样做的好处是：</p><ol><li>列表页数少，即便意外中断，顶多浪费100多次请求次数。</li><li>不进行状态记录，意外中断无需运维。</li><li>单个爬虫，操作方便。</li></ol><p>剩下就是通用性的实现。可以将xpath选择器抽象为一个类，它包含的属性为我们需要解析的字段。然后将网站上结构相同的城市归为一类，根据每种类型创建一个xpath选择器对象，这里用<code>namedtuple</code>来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">XPATH_SELECTOR = namedtuple(<span class="string">"XpathSelector"</span>, [</span><br><span class="line">    <span class="string">"max_page"</span>,</span><br><span class="line">    <span class="string">"info_list"</span>,</span><br><span class="line">    <span class="string">"house_url"</span>,</span><br><span class="line">    <span class="string">'title'</span>,</span><br><span class="line">    <span class="string">'name'</span>,</span><br><span class="line">    <span class="string">'phone'</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SH_TYPE_0 = XPATH_SELECTOR(</span><br><span class="line">    max_page=<span class="string">'//div[@class="lb_zdfy fr"]/p[@class="fl"]/span[2]/text()'</span>,</span><br><span class="line">    info_list=<span class="string">'//div[@id="qy_list_cont"]/div[@class="info_list"]'</span>,</span><br><span class="line">    house_url=<span class="string">'.//a[@class="title fl"]/@href'</span>,</span><br><span class="line">    title=<span class="string">'.//a[@class="title fl"]/text()[last()]'</span>,</span><br><span class="line">    name=<span class="string">'//div[@class="person_information"]//span[@class="p_name fl"]/text()'</span>,</span><br><span class="line">    phone=<span class="string">'//div[@class="person_info fl"]//div[@class="gr_phone_div_fr fl"]/p[1]/text()'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">SH_TYPE_1 = XPATH_SELECTOR(</span><br><span class="line">    max_page=<span class="string">'//div[@class="triggerBox"]//p[@class="number"]/text()'</span>,</span><br><span class="line">    info_list=<span class="string">'//div[@class="listPagBox"]/dl[@id="JS_listPag"]/dd'</span>,</span><br><span class="line">    house_url=<span class="string">'./div[@class="info"]/h3[@class="name"]/a/@href'</span>,</span><br><span class="line">    title=<span class="string">'./div[@class="info"]/h3[@class="name"]/a/text()[last()]'</span>,</span><br><span class="line">    name=<span class="string">'//div[@id="personal"]//p[@class="name"]/text()'</span>,</span><br><span class="line">    phone=<span class="string">'//div[@class="telephoneBox"]/div/text()'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>再做个字典，键是城市，值为xpath选择器对象，之后在解析时，只要根据城市获取对应的选择器对象进行解析即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>项目源码已上传至<a href="https://github.com/codingZXY/spider/tree/master/house365_crawler" target="_blank" rel="noopener">GitHub</a>。</p><p>以下是对公共基类base_crawler中两段代码的说明。</p><h3 id="请求公共方法"><a href="#请求公共方法" class="headerlink" title="请求公共方法"></a>请求公共方法</h3><p>在get_session中实现异步请求的公共方法，_kwargs参数可以传入请求常用的参数（如headers,data等），也可根据需求增加自定义参数。比如该项目中请求回来的源码只能用gbk来解码，因此增加了一个encoding的参数，用于传入解码方式。</p><p>bound_get_session方法通过<code>asyncio.Semaphore</code>限制并发数。discogs中并未使用该方法，而是通过对异步生成器进行切片的方式来实现并发限制。通常使用Semaphore就可满足需求，但是当数据量较大时，为节省内存，需选择后者。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">bound_get_session</span><span class="params">(self, url, _kwargs: dict = &#123;&#125;, source_type=<span class="string">"text"</span>, status_code=<span class="number">200</span>)</span> -&gt; Response:</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">            res = <span class="keyword">await</span> self.get_session(url, _kwargs, source_type, status_code)</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(random.random())</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="meta">    @retry(attempts=MAX_RETRY_TIMES)</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_session</span><span class="params">(self, url, _kwargs: dict = &#123;&#125;, source_type=<span class="string">"text"</span>, status_code=<span class="number">200</span>)</span> -&gt; Response:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param kwargs:url,headers,data,params,etc,,</span></span><br><span class="line"><span class="string">        :param method: get post.</span></span><br><span class="line"><span class="string">        :param timeout: defalut 5s.</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="comment"># 使用marshal复制提高性能</span></span><br><span class="line">        kwargs = marshal.loads(marshal.dumps(_kwargs))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> USE_PROXY:</span><br><span class="line">            kwargs[<span class="string">"proxy"</span>] = <span class="keyword">await</span> self.get_proxy()</span><br><span class="line">        method = kwargs.pop(<span class="string">"method"</span>, <span class="string">"get"</span>)</span><br><span class="line">        timeout = kwargs.pop(<span class="string">"timeout"</span>, <span class="number">5</span>)</span><br><span class="line">        encoding = kwargs.pop(<span class="string">"encoding"</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">with</span> async_timeout.timeout(timeout):</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> getattr(self.session, method)(url, **kwargs) <span class="keyword">as</span> req:</span><br><span class="line">                status = req.status</span><br><span class="line">                <span class="keyword">if</span> status <span class="keyword">in</span> [status_code, <span class="number">201</span>]:</span><br><span class="line">                    <span class="keyword">if</span> source_type == <span class="string">"text"</span>:</span><br><span class="line">                        source = <span class="keyword">await</span> req.text(encoding=encoding,errors=<span class="string">'ignore'</span>) <span class="keyword">if</span> encoding <span class="keyword">else</span> <span class="keyword">await</span> req.text()</span><br><span class="line">                    <span class="keyword">elif</span> source_type == <span class="string">"buff"</span>:</span><br><span class="line">                        source = <span class="keyword">await</span> req.read()</span><br><span class="line"></span><br><span class="line">        crawler_log.debug(<span class="string">f"get url:<span class="subst">&#123;url&#125;</span>,status:<span class="subst">&#123;status&#125;</span>"</span>)</span><br><span class="line">        res = Response(status=status, source=source)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="解析公共方法"><a href="#解析公共方法" class="headerlink" title="解析公共方法"></a>解析公共方法</h3><p>_response参数可以是Response对象、页面源码字符串、甚至是xpath节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xpath</span><span class="params">(self, _response, rule, _attr=None,clean_method=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(_response, Response):</span><br><span class="line">            source = _response.text</span><br><span class="line">            root = html.fromstring(source)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> isinstance(_response, str):</span><br><span class="line">            source = _response</span><br><span class="line">            root = html.fromstring(source)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = _response</span><br><span class="line">        nodes = root.xpath(rule)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> _attr:</span><br><span class="line">            <span class="keyword">if</span> _attr == <span class="string">"text"</span>:</span><br><span class="line">                result = [entry.text <span class="keyword">for</span> entry <span class="keyword">in</span> nodes]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = [entry.get(_attr) <span class="keyword">for</span> entry <span class="keyword">in</span> nodes]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = nodes</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> clean_method:</span><br><span class="line">            result[<span class="number">0</span>] = clean_method(result[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在学习如何使用Async/Aiohttp实现异步协程爬虫，基于cxa大佬分享的&lt;a href=&quot;https://github.com/m
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python多线程实现图片批量下载</title>
    <link href="http://yoursite.com/2019/02/28/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/02/28/Python多线程实现图片批量下载/</id>
    <published>2019-02-27T17:36:28.279Z</published>
    <updated>2019-02-27T17:57:36.752Z</updated>
    
    <content type="html"><![CDATA[<p>今天帮朋友写了个批量下载图片的脚本，之前一直以为爬取图片必须要有图片的链接地址，原来请求下载链接也可以实现。话不多说，先上需求：</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在一个Excel文件中，存有1800+个链接，每个链接包含一张图片，需实现对这些图片的批量下载。</p><p><img src="https://imagez.to/i/4A9R9nPD.png" alt="1551283857844"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>随便选了一个链接： <a href="http://data.rbge.org.uk/herb/E00025608" target="_blank" rel="noopener">http://data.rbge.org.uk/herb/E00025608</a> ， 访问该链接，确实能看到一张图片。</p><p><img src="https://imagez.to/i/ADcCyw6G.png" alt="1551284098371"></p><p>F12定位了下图片，直接就能找到这张图的url地址。</p><p><img src="https://imagez.to/i/FWF80GM6.png" alt="1551284351903"></p><p><code>.</code>代表当前路径，把它替换成当前浏览器上方显示的url，那完整的链接地址就是<a href="https://data.rbge.org.uk/search/herbarium/scripts/getzoom3.php?path=E00025608.zip;file:TileGroup0/0-0-0.jpg" target="_blank" rel="noopener">https://data.rbge.org.uk/search/herbarium/scripts/getzoom3.php?path=E00025608.zip;file:TileGroup0/0-0-0.jpg</a></p><p>直接访问该链接，是一堆乱码。试着用Python的requests库请求了下这个地址，并将返回内容写入.jpg文件，成功下载。但清晰度堪忧，且朋友对清晰度的要求还挺高，于是又想了下其他方式，发现，图片是可以点击的，跳转到的网站是这样的：</p><p><img src="https://imagez.to/i/ITjLDcVB.png" alt="1551285295190"></p><p>网站下方<code>Get Tiff</code>按钮支持图片的下载，且可以自行选择像素大小。试着点击按钮并抓了下包，发送的请求为</p><p><img src="https://imagez.to/i/o6fRdJYf.png" alt="1551285615659"></p><p>同样用requests模拟这个请求，成功下载。这个请求包含两个参数，base和tier，base可理解为图片id，在Excel文件的链接中能找到；tier表示网站支持选取的七个像素，从0-6递增，6代表5677x8343。那么只要读取到Excel文件中的图片id，再循环模拟请求就能实现批量下载了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>完整代码已上传至<a href="https://github.com/codingZXY/spider/tree/master/GBIF" target="_blank" rel="noopener">GitHub</a> ,这里贴两段关键代码。</p><h4 id="读取Excel中的图片id并放入队列"><a href="#读取Excel中的图片id并放入队列" class="headerlink" title="读取Excel中的图片id并放入队列"></a>读取Excel中的图片id并放入队列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base_list</span><span class="params">(self)</span>:</span></span><br><span class="line">        wb = load_workbook(self.file_name)</span><br><span class="line">        sheet = wb.active</span><br><span class="line">        rows = list(sheet.rows)[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">            s = re.search(<span class="string">r'http://data.rbge.org.uk/herb/(.*)'</span>,row[<span class="number">1</span>].value)</span><br><span class="line">            base = s.group(<span class="number">1</span>).strip()</span><br><span class="line">            self.base_queue.put(base)</span><br></pre></td></tr></table></figure><p>读取Excel使用了openpyxl库的load_workbook方法，使用<code>sheet = wb.active</code>获取当前Sheet，用<code>rows = list(sheet.rows)[1:]</code> 获取所有行，并用切片过滤首行的列头。之后用正则提取图片id并放入队列中，供下载线程的调用。</p><h4 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.base_queue.empty():</span><br><span class="line">            base = self.base_queue.get()</span><br><span class="line">            print(<span class="string">f'正在下载图片<span class="subst">&#123;base&#125;</span>...'</span>)</span><br><span class="line">            url = self.download_url.format(base=base,tier=self.tier)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    response = requests.get(url,headers=self.headers,stream=<span class="keyword">True</span>)</span><br><span class="line">                    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                        <span class="keyword">with</span> open(<span class="string">f'<span class="subst">&#123;self.save_dir&#125;</span>/<span class="subst">&#123;base&#125;</span>_<span class="subst">&#123;self.tier&#125;</span>.tiff'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                            <span class="keyword">for</span> chunk <span class="keyword">in</span> response.iter_content(<span class="number">100000</span>):</span><br><span class="line">                                f.write(chunk)</span><br><span class="line"></span><br><span class="line">                        print(<span class="string">f'图片<span class="subst">&#123;base&#125;</span>下载完成。'</span>)</span><br><span class="line">                        time.sleep(random.random())</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    print(<span class="string">f'请求出错,地址：<span class="subst">&#123;url&#125;</span> 错误：<span class="subst">&#123;e&#125;</span> 正在重新请求(<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>)...'</span>)</span><br><span class="line">                    time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>该函数不断从队列中提取图片id，传入事先定义好的下载链接（之前点击下载按钮抓包抓到的那个链接），请求该链接并将返回内容写入文件，直到队列为空则停止。</p><p>之后将此函数作为线程的目标函数即可实现多线程下载。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天帮朋友写了个批量下载图片的脚本，之前一直以为爬取图片必须要有图片的链接地址，原来请求下载链接也可以实现。话不多说，先上需求：&lt;/p&gt;
&lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python+Appium实现群控软件的快速开发</title>
    <link href="http://yoursite.com/2019/02/22/Python+Appium%E5%AE%9E%E7%8E%B0%E7%BE%A4%E6%8E%A7%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/02/22/Python+Appium实现群控软件的快速开发/</id>
    <published>2019-02-22T15:25:53.939Z</published>
    <updated>2019-02-27T17:52:52.469Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>群控软件：使用计算机程序控制多台移动端设备的App，进行一些定制化的自动操作。</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近应客户需求，开发了几款基于Appium框架的群控软件，如微信自动加好友、抖音自动关注等。将开发过程中用到的一些公共方法进行了封装，用于实现此类软件的快速开发。本文将以QQ自动加好友为例，从需求分析、流程设计、代码编写三个步骤，说说如何实现群控软件的快速开发。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>客户的需求通常不会十分明确，特别是这类群控软件，可能需求就两句话：“小张啊，我现在有几万个淘宝商家的QQ号，你看能不能写个程序自动添加成好友？”。</p><p>那么针对这样一个两句话的需求，如何进行需求分析呢？首先从可行性的角度去考虑，在脑海中模拟一下，想要实现这个需求，会遇到哪些问题，然后将问题一一列出，如QQ自动加好友：</p><ol><li>QQ是否有添加好友的开放接口？</li><li>如果没有开放接口，就需要模拟人为操作，那要选用哪个平台？PC端还是移动端？</li><li>这几万个QQ号现在存在哪里？数据库还是Excel文件？</li><li>用于添加这几万个QQ号的QQ是一个还是多个？如果是多个，是将几万个QQ号平均分配还是全部添加？</li><li>……</li></ol><p>将这些问题分为两类：技术类（1、2）和业务类（3、4）。将技术类的问题解决后，带着业务类问题与客户进行讨论和确认。以下是技术验证并与客户讨论需求后得出的结论：</p><ol><li>暂时没有找到QQ添加好友的开放接口，因此选择以模拟人为操作的方式实现。</li><li>在PC端操作的话，只能通过坐标定位去模拟，该方式稳定性低；而Appium框架支持手机App中的元素选择，相对来说稳定性较高，因此选用移动端。</li><li>QQ号现在存在Excel文件中，文件包含两个字段：商家名称、QQ号。</li><li>多个QQ，全部添加。</li><li>……</li></ol><p>确保这些问题全部解决后，就可以进入下一步，流程设计了。</p><h2 id="流程设计"><a href="#流程设计" class="headerlink" title="流程设计"></a>流程设计</h2><p>流程设计是群控软件的所有开发环节中最简单的一环，只需要电脑连接手机后，配合Appium桌面版，在手机上模拟一遍操作流程，将自动化操作步骤和对应的元素选择器记录下来就行。</p><p>比如QQ加好友的步骤为：打开手机QQ→点击右上角的加号→点击加好友→输入QQ号→点击找人→点击加好友→输入验证消息→输入备注→点击发送→点击返回→继续输入QQ号。将这些步骤中涉及到的按钮、文本框等元素的选择器进行记录，通常会通过id或xpath进行选择。</p><p>其实就是为接下来编写代码提前打了个草稿，这个过程本是可以在编写代码的时候进行的，但加入这个环节，提前考虑好流程，并将元素选择器准备好，可以有效提高开发效率。</p><p>以下是QQ自动加好友的流程设计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">点击加号</span><br><span class="line">xpath://android.widget.ImageView[@content-desc=&quot;快捷入口&quot;]</span><br><span class="line"></span><br><span class="line">点击加好友</span><br><span class="line">xpath://android.widget.LinearLayout[@content-desc=&quot;加好友/群 按钮&quot;]</span><br><span class="line"></span><br><span class="line">输入QQ号</span><br><span class="line">xpath://android.widget.EditText[@content-desc=&quot;搜索栏、QQ号、手机号、群、公众号&quot;]</span><br><span class="line">id:com.tencent.mobileqq:id/et_search_keyword</span><br><span class="line"></span><br><span class="line">点击找人</span><br><span class="line">xpath://android.widget.LinearLayout[@content-desc=&quot;找人:&#123;当前添加的QQ号&#125;&quot;]</span><br><span class="line"></span><br><span class="line">点击加好友</span><br><span class="line">id:com.tencent.mobileqq:id/txt</span><br><span class="line"></span><br><span class="line">输入验证消息</span><br><span class="line">xpath://android.widget.RelativeLayout/android.widget.EditText[@resource-id=&quot;com.tencent.mobileqq:id/name&quot;]</span><br><span class="line"></span><br><span class="line">输入备注</span><br><span class="line">xpath://android.widget.LinearLayout/android.widget.EditText[@resource-id=&quot;com.tencent.mobileqq:id/name&quot;]</span><br><span class="line"></span><br><span class="line">点击发送</span><br><span class="line">id:com.tencent.mobileqq:id/ivTitleBtnRightText</span><br><span class="line"></span><br><span class="line">点击返回</span><br><span class="line">xpath://android.widget.TextView[@resource-id=&quot;com.tencent.mobileqq:id/ivTitleBtnLeft&quot; and @text=&quot;返回&quot;]</span><br><span class="line"></span><br><span class="line">从第三步开始循环</span><br></pre></td></tr></table></figure><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><p>项目源码已上传至<a href="https://github.com/codingZXY/AppiumProjects/tree/master/qq" target="_blank" rel="noopener">GitHub</a>。</p><p>其中，核心的几个文件为：</p><ul><li><p>oappium.py</p><p>实现了两个基类：AppiumAutoTool和MultiAppium。</p></li><li><p>qqaf_auto_tool.py</p><p>继承oappium.py中的AppiumAutoTool，实现自动化流程。</p></li><li><p>qqaf_auto_tool_multi.py</p><p>继承oappium.py中的MultiAppium，实现手机的集群控制。</p></li><li><p>qqaf_auto_tool_ui.py</p><p>使用QtDesiner+PyUic生成的PyQt界面源码。</p></li><li><p>main.py</p><p>连接界面层和底层脚本，进行界面交互和功能整合。</p></li></ul><p>具体代码不做展开说明，可自行参考源码。</p><h3 id="集群控制的实现思路"><a href="#集群控制的实现思路" class="headerlink" title="集群控制的实现思路"></a>集群控制的实现思路</h3><p>首先简单介绍一下<a href="http://appium.io/" target="_blank" rel="noopener">Appium</a>。Appium是一个移动端App的自动化测试框架，使用Python开发时需要安装第三方库<a href="https://github.com/appium/python-client" target="_blank" rel="noopener">Appium-Python-Client</a>，使用该框架能完成一些App上的自动化任务，甚至是爬虫任务。</p><p>这有点类似PC端的selenium，不用去关心数据接口和接口参数，而是模拟人工的点击、输入、滑动等操作，并返回界面源码，做到可见即可爬。</p><p>Appium控制单台设备的实现方式是，首先开启一个Appium服务器（端口默认为4723），再根据Desired Capabilities（设备及App的相关参数）加上对应的服务器端口（4723）来启动driver驱动来进行控制。</p><p>因此多设备集群控制的实现思路就是，使用多线程，根据设备数量在不同端口启动多个Appium服务器，再配置对应的设备参数在对应端口启动多个driver驱动。集群控制的实现代码在oappium.py中的MultiAppium类中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;群控软件：使用计算机程序控制多台移动端设备的App，进行一些定制化的自动操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Markdown for Typora使用手册</title>
    <link href="http://yoursite.com/2019/02/22/Markdown%20for%20Typora%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2019/02/22/Markdown for Typora使用手册/</id>
    <published>2019-02-22T13:49:59.835Z</published>
    <updated>2019-02-27T17:52:16.331Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自Typora的官方手册</p></blockquote><p>[TOC]</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>之前一直想用Markdown来写东西，苦于找不到一个好用的Markdown编辑器，直到发现了Typora，用上之后就停不下来了。Typora是一个简洁优雅且免费的Markdown编辑器，它支持多平台（Mac/Windows/Linux），下载链接在<a href="https://www.typora.io/" target="_blank" rel="noopener">这里</a>。以下内容参考自Typora的官方手册，原文链接在<a href="https://support.typora.io/Markdown-Reference/" target="_blank" rel="noopener">这里</a>。</p><h2 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h2><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><p>在Markdown源码中，段落之间需要用两个以上的空行分开，在Typora中，只需要一个空行（敲一下回车）来写新的段落。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题使用一个到六个（<code>#</code>）号放在一行的开头来定义，代表一级标题到六级标题。例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">###### 这是六级标题</span></span><br></pre></td></tr></table></figure></p><h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><p>使用（<code>&gt;</code>）号放在引用内容的开头来使用引用块，如果引用块跨多个段落，就在段落间的空行加上（<code>&gt;</code>）例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是包含了两个段落内容的引用块。 这是第一段。</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt; 这是第二段</span></span><br></pre></td></tr></table></figure></p><p>效果：</p><blockquote><p>这是包含了两个段落内容的引用块。 这是第一段。</p><p>这是第二段</p></blockquote><p>若要使用内嵌引用块，则使用多个（<code>&gt;</code>）号，如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 这是一个套了两层的内嵌引用块</span><br></pre></td></tr></table></figure></p><p>效果：</p><blockquote><blockquote><p>这是一个套了两层的内嵌引用块</p></blockquote></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>使用（<code>*</code>）/（<code>+</code>）/（<code>-</code>）来创建无序列表，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*   </span>Red</span><br><span class="line"><span class="bullet">*   </span>Green</span><br><span class="line"><span class="bullet">*   </span>Blue</span><br></pre></td></tr></table></figure></p><p>效果：</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><p>使用（<code>1.</code>）来创建有序列表，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>Red</span><br><span class="line"><span class="bullet">2. </span>Green</span><br><span class="line"><span class="bullet">3. </span>Blue</span><br></pre></td></tr></table></figure></p><p>效果：</p><ol><li>Red</li><li>Green</li><li>Blue</li></ol><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>使用（<code>- [ ]</code>）或（<code>- [x]</code>）创建任务列表，x代表默认勾选。例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>[x] 任务1</span><br><span class="line"><span class="bullet">- </span>[ ] 任务2</span><br><span class="line"><span class="bullet">- </span>[ ] 任务3</span><br><span class="line"><span class="bullet">- </span>[ ] 任务4</span><br></pre></td></tr></table></figure></p><p>效果：</p><ul><li style="list-style: none"><input type="checkbox" checked> 任务1</li><li style="list-style: none"><input type="checkbox"> 任务2</li><li style="list-style: none"><input type="checkbox"> 任务3</li><li style="list-style: none"><input type="checkbox"> 任务4</li></ul><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>在Typora中，输入<code>| First Header  | Second Header |</code> 并按下回车，会创建一个包含两列的表格，点击表格可以使用表格的功能菜单直接对表格进行编辑。表格语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| First Header  | Second Header |</span><br><span class="line">| ------------- | ------------- |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br><span class="line">| Content Cell  | Content Cell  |</span><br></pre></td></tr></table></figure><p>效果：<br>| First Header  | Second Header |<br>| ————- | ————- |<br>| Content Cell  | Content Cell  |<br>| Content Cell  | Content Cell  |</p><p>在列头加上冒号可以控制内容单元格的对齐方式，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Left-Aligned  | Center Aligned  | Right Aligned |</span><br><span class="line">| :------------ |:---------------:| -----:|</span><br><span class="line">| col 3 is      | some wordy text | $1600 |</span><br><span class="line">| col 2 is      | centered        |   $12 |</span><br><span class="line">| zebra stripes | are neat        |    $1 |</span><br></pre></td></tr></table></figure></p><p>效果：<br>| Left-Aligned  | Center Aligned  | Right Aligned |<br>| :———— |:—————:| —–:|<br>| col 3 is      | some wordy text | $1600 |<br>| col 2 is      | centered        |   $12 |<br>| zebra stripes | are neat        |    $1 |</p><p>除此之外，表格内容还支持加粗、斜体、超链接等语法。</p><h3 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h3><p>可以像这样创建注脚：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^注脚]：指解释字句的文字，也泛指解释、说明。</span><br></pre></td></tr></table></figure></p><p>效果：</p><p>啥是<a href="指解释字句的文字，也泛指解释、说明。">^注脚</a>？</p><h3 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h3><p>在一个空行后输入<code>***</code>或<code>---</code>来生成一条水平线。<br>例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>效果：</p><hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>输入[toc]按下回车，会根据标题自动创建目录</p><h2 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h2><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>使用<code>[链接内容](链接地址 &quot;标题&quot;)</code>来创建超链接，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个[<span class="string">超链接</span>](<span class="link">http://example.com/ "鼠标移至显示标题"</span>)的例子.</span><br></pre></td></tr></table></figure></p><p>效果：<br>这是一个<a href="http://example.com/" title="鼠标移至显示标题" target="_blank" rel="noopener">超链接</a>的例子.</p><h4 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h4><p>Markdown支持创建指向文章标题的内部链接，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个内部链接的例子，Ctrl+鼠标左键点击[<span class="string">这里</span>](<span class="link">#块元素</span>)跳至<span class="code">`块元素`</span>标题</span><br></pre></td></tr></table></figure></p><p>效果：<br>这是一个内部链接的例子，Ctrl+鼠标左键点击<a href="#块元素">这里</a>跳至<code>块元素</code>标题</p><h4 id="引用链接"><a href="#引用链接" class="headerlink" title="引用链接"></a>引用链接</h4><p>若文章中多处用到同一个超链接，可以使用引用链接。使用两个中括号来创建，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是一个引用链接的[<span class="string">例子</span>][<span class="symbol">id</span>]。</span><br><span class="line"></span><br><span class="line">然后在文章的任意位置为id赋值。</span><br><span class="line"></span><br><span class="line">[<span class="symbol">id</span>]: <span class="link">http://example.com/  "此处为标题，可空"</span></span><br></pre></td></tr></table></figure></p><p>效果：</p><p>这是一个引用链接的<a href="http://example.com/" title="此处为标题，可空" target="_blank" rel="noopener">例子</a>。</p><p>然后在文章的任意位置为id赋值。</p><p>若第二个中括号为空，则链接内容可以作为id使用，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">百度</span>][<span class="symbol"></span>]</span><br><span class="line">[<span class="symbol">百度</span>]:<span class="link">https://www.baidu.com/</span></span><br></pre></td></tr></table></figure></p><p>效果：<br><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a></p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>若内容是个URL地址，可以用<code>&lt;&gt;</code>来包裹，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i@typora.io&gt;</span><br></pre></td></tr></table></figure></p><p>效果：<br> <a href="mailto:&#x69;&#64;&#116;&#x79;&#112;&#x6f;&#x72;&#97;&#x2e;&#105;&#111;" target="_blank" rel="noopener">&#x69;&#64;&#116;&#x79;&#112;&#x6f;&#x72;&#97;&#x2e;&#105;&#111;</a></p><p>Typora会自动检测标准的URL地址，比如：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>插入图片的语法为<code>![文件名](文件路径)</code>，和超链接类似，需要在中括号前加个<code>！</code>。例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片示例1</span>](<span class="link">/path/to/img1.jpg</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">图片示例2</span>](<span class="link">/path/to/img2.jpg "此处为标题，可空"</span>)</span><br></pre></td></tr></table></figure></p><p>在Typora中，可以直接将图片拖入编辑器来插入图片。</p><p>若文章要发布到网上，那么肯定不能使用图片的本地路径。这时候就需要用到图床了，图床是指专门用来存放图片的服务器，可以用它来生成图片的永久外链。这里使用<a href="https://thumbsnap.com/" target="_blank" rel="noopener">Thumbsnap</a>来生成，Thumbsnap支持多种图片格式，无需注册即可免费使用。使用图床生成图片链接后，将文件路径替换为链接即可，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">typora</span>](<span class="link">https://thumbsnap.com/i/iF31zInH.png?0221 "图片示例"</span>)</span><br></pre></td></tr></table></figure><p><img src="https://thumbsnap.com/i/iF31zInH.png?0221" alt="typora" title="图片示例"></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>使用(<code>*</code>)或(<code>_</code>)来包裹文本，可以将文本变成斜体。例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*使用星号渲染为斜体的文本*</span></span><br><span class="line"><span class="emphasis">_使用下划线渲染为斜体的文本_</span></span><br></pre></td></tr></table></figure></p><p>效果：<br><em>使用星号渲染为斜体的文本</em><br><em>使用下划线渲染为斜体的文本</em></p><p>由于下划线经常用于变量的命名，<a href="https://help.github.com/articles/github-flavored-markdown/" target="_blank" rel="noopener">GFM</a>会忽略对这类斜体渲染。例如wow_great_stuff中的great并没有渲染成斜体。</p><p>若文本被<code>*</code>包裹，又不想显示斜体，可以在<code>*</code>前加上反斜杆<code>\</code>，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\<span class="emphasis">*被星号包裹的文本\*</span></span><br></pre></td></tr></table></figure></p><p>效果：<br>*被星号包裹的文本*</p><p>Typora推荐使用星号(<code>*</code>)来渲染斜体。</p><h3 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h3><p>使用双星号(<code>**</code>)或双下划线(<code>__</code>)来包裹文本，可以将文本变成粗体。例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**使用双星号渲染为粗体的文本**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__使用双下划线渲染为粗体的文本__</span></span><br></pre></td></tr></table></figure></p><p>效果：<br><strong>使用双星号渲染为粗体的文本</strong></p><p><strong>使用双下划线渲染为粗体的文本</strong></p><p>Typora推荐使用双星号(<code>**</code>)来渲染粗体。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>行内代码使用倒引号(`)来包裹，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个<span class="code">`行内代码`</span>。</span><br></pre></td></tr></table></figure></p><p>效果：<br>这是一个<code>行内代码</code>。</p><p>代码块使用三个倒引号(```)来包裹。</p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><a href="https://help.github.com/articles/github-flavored-markdown/" target="_blank" rel="noopener">GFM</a>添加了删除线的语法，在标准的Markdown语法中是没有的。<br>使用双波浪线(<code>~~</code>)来为文本添加删除线，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~被删除的文本~~</span><br></pre></td></tr></table></figure><p>效果：<br><del>被删除的文本</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线使用原生的HTML代码来生成。例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;带下划线的文本&lt;/u&gt;</span><br></pre></td></tr></table></figure></p><p>效果：<br><u>带下划线的文本</u></p><h3 id="表情符"><a href="#表情符" class="headerlink" title="表情符"></a>表情符</h3><p>输入表情符，可自动转换为表情，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:smile:</span><br></pre></td></tr></table></figure></p><p>效果：<br>:smile:</p><p>更多表情符，见<a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">这里</a>。</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>可以使用HTML语法来为内容添加样式，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;color:red&quot;&gt;用HTML语法改变字体颜色为红色&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>效果：<br><span style="color:red">用HTML语法改变字体颜色为红色</span></p><p>但纯Markdown并不支持这种操作。</p><h3 id="嵌入内容"><a href="#嵌入内容" class="headerlink" title="嵌入内容"></a>嵌入内容</h3><p>有些网站提供了基于iframe的嵌入代码，可以直接拷贝至Typora。例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">height</span>=<span class="string">'265'</span> <span class="attr">scrolling</span>=<span class="string">'no'</span> <span class="attr">title</span>=<span class="string">'Fancy Animated SVG Menu'</span> <span class="attr">src</span>=<span class="string">'http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2'</span> <span class="attr">frameborder</span>=<span class="string">'no'</span> <span class="attr">allowtransparency</span>=<span class="string">'true'</span> <span class="attr">allowfullscreen</span>=<span class="string">'true'</span> <span class="attr">style</span>=<span class="string">'width: 100%;'</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>效果：</p><iframe height="265" scrolling="no" title="Fancy Animated SVG Menu" src="http://codepen.io/jeangontijo/embed/OxVywj/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;"></iframe><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>使用HTML的<code>&lt;video&gt;</code>标签来嵌入视频，例如：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"http://edge.ivideo.sina.com.cn/141968369.mp4?KID=sina,viask&amp;Expires=1551024000&amp;ssig=AcZJje8UOc"</span> /&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>效果：</p><video src="http://edge.ivideo.sina.com.cn/141968369.mp4?KID=sina,viask&Expires=1551024000&ssig=AcZJje8UOc"><h3 id="其他HTML语法的支持"><a href="#其他HTML语法的支持" class="headerlink" title="其他HTML语法的支持"></a>其他HTML语法的支持</h3><p>更多Typora对HTML的支持在<a href="http://support.typora.io/HTML/" target="_blank" rel="noopener">这里</a>可以找到。</p></video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文参考自Typora的官方手册&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;之前一直想用
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/02/04/hello-world/"/>
    <id>http://yoursite.com/2019/02/04/hello-world/</id>
    <published>2019-02-04T05:06:42.570Z</published>
    <updated>2019-02-04T05:06:42.571Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
